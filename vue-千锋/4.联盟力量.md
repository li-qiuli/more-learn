# Vue CLI3使用

test.vue

```html
<template>
</template>
<script>
    module.export={
        data:function(){
            return{
                
            }
        }
    }
</script>
<style scoped>
</style>
```
npm install -g @vue/cli (一次安装) vue --version 查看版本
vue create myapp
* npm run serve 开发环境构建
* npm run build 生产环境构建
* npm run lint 代码检测工具

```javascript
new Vue({
    render:h=>h(App)
}).$mount('#app')
```

完整语法高亮
CommonJS 模块
组件作用域的 CSS

## eslint(风格统一)
（双引号）--单引号
（多个空行）--一个
（=空格）
定义未使用
最后一个有空行

调整eslint方案：
1. vscode 自动修复***与eslint/vscode版本息息相关（会偶尔不好用）***
    安装eslint插件并启用
    【文件】=》【首选项】=》【设置】=》用户，找到setting.json,加上一下配置

```json
"editor.codeActionsOnSave":{
    "source.fixAll":true
}
```
2. 关闭eslint(最后打开，一次性修复) 
    vue.config.js【vue 项目配置文件覆盖】--lintOnSave:false  
```javascript
module.exports={
    lintOnSave:false 
    //暂时关闭代码格式检测
}
```
    老版本还需加：   
    .eslintrc 删除'@vue/standard' (对于某个规则关闭，no-new:"off")

## 单文件组件（高亮显示：vetur）
建议：组件大写，文件夹小写
```html
<!-- App.vue -->
<template>
<div>
    parent
    <NavBar></NavBar>
</div>
</template>
<script>
import navbar from './NavBar.vue' 

// 1.!!!需要注册【全局】
import Vue from 'vue'
Vue.comontent('navbar',navbar)

//自动定义指令使用
Vue.directive('hello',{
    inserted(el,bingding){
        el.style.border="1px solid black"
    }
})
//过滤器
Vue.filter('img',(path)=>{
    return path
})
//可认为模版会自动导出，js不会（需导出，我们也可导入东西）
// es6导出规范
export default {
    data(){
        return{
        }
    },
    //2. 局部注册
    components:{
      navbar  
    }
    methods:{
    }
}
</script>
<!-- lang 语言-->
<style lang="scss">

</style>
```
----------------------------------------
```html
<!-- NavBar.vue -->
<template>
<div>
    child
</div>
</template>
<script>
export default {
    props:[]
    data(){
        return{}
    },
    methods:{}
}
</script>
<!-- lang=语言 -->
<!-- scoped:加scoped 样式节点会有个唯一的属性，样式会做属性选择器的对应 -->
<style lang="scss" scoped>
</style>
```
样式会被覆盖（先插入子组件样式节点）

组件通信(同非单文件组件)

...public/test.json (public不用敲--因为时默认的静态目录)
loaclhost:8080/test.json

## 反向代理&别名

跨域问题:
    后端部署到（服务器/局域网），能访问到  
    1. jsonp (不能发post,只能get)
    2. 反向代理
        删掉域名：端口号=>朝自己发请求=》配置自己的本地服务器=》让服务器给服务器发请求

       
```javascript
vue.config.js
module.exports={
    lintOnSave:false,

    //别名配置
    configureWebpack:{
        // epub无configureWebpack:{}
        resolve:{
            alias:{
                "@":'src'
            }   
        }
    }

    // 配置反向代理
    devServer:{
        port:8080,
        proxy:{
            '/ajax':{
                target:"https://m.maoyan.com",
                changeOrigin:true
            },
            '/ajax':{
                target:"https://m.maizuo.com",
                changeOrigin:true
            }

            //当都有ajax,代理到不同地方:pathRewrite
            '/test1/ajax':{
                target:"https://m.maoyan.com",
                changeOrigin:true,
                // 路径重写
                pathRewrite:{
                    '^/test1/ajax':'/ajax'
                }
            },
            '/test2/ajax':{
                target:"https://m.maizuo.com",
                changeOrigin:true,
                pathRewrite:{
                    '^/test2/ajax':'ajax'
                }
            }
        }
    }
} 
//@ 【是webpack配置别名】===》指向src的绝对路径
```
# 路由 
切换-无浏览器重载（单页面应用SPA）
![](./img/img11.png)
![](./img/img12.png)

公司官网需：seo  
电商、求职网站：一般不seo

***路由原理***：监听路由改变（dom），改变组件(更新视图但不重新请求页)  
1. hash路由==>location.hash或者路由
    **window.onhashchange**监听路径切换 
2. history路由==> history.pushState切换 
    **window.onpopstate**监听路径切换  

## vue-router
安装：
    npm install --save vue-router

路径与组件映射关系 的映射表（路由框架）

## 一级路由

```javascript
//main.js
import router from './router'
new Vue({
    //路由配置
    router,
    render:h=>h(App)
}).$mount('#app')
```
---------------
```javascript
//router/index.js

import Vue from 'vue'
import VueRouter from 'vue-router'

import Films from './Films.vue'
import Cinemas from './Cinemas.vue'

Vue.use(VueRouter) //注册路由插件【两个全局组件router-view、router-link】
const router =new VueRouter({
    mode:'history',
    //默认 hash   
    //history:如果浏览器不支持 history 新特性，则采用 hash
    //如果不在浏览器环境下，就采用 abstract（Node环境下）
    base:process.env.BASE_URL,
    routes
})

// 配置表
const routes = [
  {
    path: '/films',
    component: Films //路由组件不用注册
  },
  {
    path: '/cinemas',
    component: Cinemas
  },
{
    path: '/films/nowplaying',
    component: Cinemas
  },
  {
    path: '*',
    //通配符（都不匹配，就自动匹配到films,与放前面与后面无关）
    //path: '/',
    //重定向 
    redirect: '/films'
  }
]
```
---------------
```html
<!-- App.vue -->
<template>
<div>
    <!-- 路由容器 -->
    <router-view></router-view>
    <router-view></router-view>
    <!-- 插槽的二次封装 -->
</div>
</template>
<script>
</script>
```
原理同：location.href=''

***路由切换高亮***监听路径改变
## 声明式导航
![](./img/img13.png)
`<router-link to="/cinemas">`   

tag="div" vue3之前可以用 vue4不能用,但可以嵌套标签
```html
<!-- isActive标记是否激活中，action-class也不需要了 -->
<!--  navigate：触发导航的函数 -->
 <router-link custom v-slot="{navigate,isActive}" to="/films">
    <li @click="navigate">电影</li>
 </router-link>
```

```html
<!-- App.vue -->
<template>
<div>
    <router-link action-class="testautum" to="/films">电影</router-link>
    <!-- testautum会替换router-link-active -->
    <router-link to="/cinemas">影院</router-link>
    <!-- 路由容器 -->
    <router-view></router-view>
</div>
</template>
<script>
</script>
<style>
/* 可替换 */
.router-link-active{
    color:red
}
</style>
```

## 嵌套路由
```html
<!-- Films.vue -->
<template>
<div>
    <div>我是轮播</div>

    <div>
        <router-link action-class="testautum" to="/films/nowplaying">热映</router-link>
        <router-link to="/cinemas">即将上线</router-link> 
    </div>

    <!-- 路由容器 -->
    <router-view></router-view>
</div>
</template>
<script>
</script>
<style>
/* 可替换 */
.router-link-active{
    color:red
}
</style>
```

<router-view> 是用来渲染通过路由映射过来的组件，当路径更改时，<router-view> 中的内容也会发生更改
children
children 配置就是像 routes 配置一样的路由配置数组，所以呢，你可以嵌套多层路由

## 编程式导航
location.href=''

## 动态路由
## 命名路由
## 路由模式

## 路由拦截
 
 全局
 局部

vue-router 导航解析流程
1.导航被触发；
2.在失活的组件里调用beforeRouteLeave守卫；
3.调用全局beforeEach守卫；
4.在复用组件里调用beforeRouteUpdate守卫；
5.调用路由配置里的beforeEnter守卫；
6.解析异步路由组件；
7.在被激活的组件里调用beforeRouteEnter守卫；
8.调用全局beforeResolve守卫；
9.导航被确认；
10..调用全局的afterEach钩子；
11.DOM更新；
12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。

vue-router的几种实例方法以及参数传递
name传递
to来传递
采用url传参
## 路由懒加载


# Vuex 

# 组件库 