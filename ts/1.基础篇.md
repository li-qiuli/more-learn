# 优化编译
1. 解决ts和js冲突问题（文件名相同报错）
tsc --init  #生成编译文件

2. 自动编译 tsc --watch
3. 出现错误时，不编译 tsc --noEmitOnError hello.ts --watch

# 显式类型
```javascript
function greet(per:string,data:Date){
    console.log(``)
}
// Date() 字符串
greet('li',new Date())


let msg='ssss'
// 无显式类型，会自动推断类型
```
# 降级编译(例如：es6模版字符串语法)&严格模式
tsconfig.json
ts7-->es2016
```json
{
    "target":"es5", //默认es3

    // ts默认宽松验证：验证程序某些部分，类型可选，推理采用最宽松类型(比如：any)，不检查潜在的null undefinded
   
   // 严格模式
    "strict":true,
    "noImplicitAny":true, //判断any类型

    "stricNullChecks":true,
    // let a:string=undefined
    // let b:string=null

    "rootDir":"./src",
    "outDir":"./dist"
}
```
# 类型
常用类型（基元类型）：string number(无int/float) boolean
对象类型:除了元类型的类型
数组：type[] Array`<type>`  type:任意合法类型

any:不希望某个特定值导致类型检查错误

函数：()=>void
```javascript
function greet(per:string,data:Date):viod{
    console.log(``)
}
```
联合类型：|
类型别名：type Id=string
接口：
```javascript
interface Point {
    x:string
}
```
## **扩展**
***类型别名与接口的不同：***

扩展接口：
```javascript
interface Point {
    x:string
}
interface PointChild extend Point{
    y:number
}
const a:PointChild={x:'111',y:2333}
```

type扩展（交叉扩展）：&
```javascript
type Point= {
    x:string
}
type PointChild = Point&{y:number}

const a:PointChild={x:'111',y:2333}
```

现有类型添加字段：
```javascript
// interface 通过同名添加（type不能，只能通过交叉点方式加&）
interface Point {
    x:string
}
interface Point {y:number}

const a:Point={
    x:'111',
    y:2333
}
```
HTMLElement、HTMLCanvasElement
**类型断言：as**

```javascript
const canvasdom=document.getElementById("mian_canvas") as HTMLCanvasElement
// 等价
const canvasdom=<HTMLCanvasElement>document.getElementById("mian_canvas")
```
只能允许转化为更具体或不太具体的类型版本（防止不可能的强制的发生）
```javascript
let a='hello' as number //错误
==>正确
let a=（'hello' as any) as number
let a=（'hello' as unkonwn) as number
//实现不知道什么类型时断言为一个差不多的类型 
```

**文字类型**

