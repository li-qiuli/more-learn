1. 路由引入 
2. 一级路由与多级路由 
3. 路由重定向 
4. 嵌套路由
```javascript
<HashRouter> 
{this.props.children} 
//Switch ===case 以防刷新时路由改变 
<Switch> 

<Route path='/films' component={Films}/> 
<Route path='/center' component={Center}/> 
//模糊匹配  

//动态路由  /detail/1111 
<Route path='/detail/:myid' component={Detail}/> 
//exact精确匹配：以防不出现默认404界面 
<Redirect from="/" to="/films" exact/> 
<Route component={NotFound}/> 

</Switch> 
</HashRouter> 
```
5. 声明式导航与编程式导航 
声明式导航：<NavLink to=''></NavLink>
编程式导航：  
```javascript
<Switch> 
//Films 页面多级路由 
<Route path='/films/nowplaying' component={NowPlaying}> 
</Switch> 
//NowPlaying 组件为route的子组件；NowPlaying 的props带有路由跳转的方法history、location（路径）、match 
props.history.push(`/detail/${id}`) 

```
Hooks: 

react-router-dom(useHistory) 
const history=useHistory 

history.push(`/detail/${id}`) 
6. 动态路由 
- 路由传参 :Detail 页面能拿到props.match.params.myid
-  query传参 
```javascript
<Route path='/detail' component={Detail}/> 
props.history.push({ 
pathname:'/user',
query:{ 
day:'Friday' 
} 

}) 

 

===>props.location.query.day 
```
- state传参 
```javascript
props.history.push({ 

pathname:'/user', 

state:{ 

day:'Friday' 

} 

}) 
//props.location.state.day 
```

query传参、state传参 ：分享链接没有ID 

7. 路由拦截 
```javascript
<Route path='/center' render={()=>isAuth()?<Center/>:<Login/>}/> 

//路由未改变 

 

===> 

<Route path='/center' render={()=>isAuth()?<Center/>:<Redirect from="/login"/>}/> 

<Route path='/login' component={Login}/> 

//后端401 在axios中拦截 
```
8. 路由模式 
#hash :#只是前端接收界面改变 <HashRouter> 

无#:<BrowserRouter> 

好看；真正朝后端发请求要页面（认为后端路由），后端没有对应的路径处理，就会404。 

解决： 

跟后端确认，不合法路径重新渲染index.html 
9. withRouter(高阶组件) 
 
```javascript
<Route path='/center' render={(props)=>isAuth()?<Center myid={}/>:<Redirect from="/login"/>}/> 
```
把center自己给实例化，所以props没有route传的数据；在render中取 

Route 源码简单解析 
![img]()
```javascript
import {withRouter} from 'react-router 

 

const WithMyCompontent= withRouter(MyCompontent) 

给MyCompontent隔空提供props.location 

 

withRouter(connect(…)(MyCompontent)) 
```
 